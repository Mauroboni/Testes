= Testes de _software_
Mauro Henrique Lima de Boni - mauro@ifto.edu.br
2018-08-20
//criar conta no Gitbook e verificar a integra√ß√£o do Github com ele.
// endere√ßo no gitbooks
// https://ifto.gitbook.io/testes-de-_software_/.

:appversion: 1.0.0
:doctype: book
:chapter-label:
:sectnums:
:allow-uri-read:
:imagesdir: imagens
:safe: unsafe
:icons: font
// √© poss√≠vel usar um simblo obtido por um codigo unicode!
:tip-caption: üí°
:toc:
//:tip-caption: pass:[&#128161;]
//üîç
//lupa inclinada para a esquerda
//Unicode: U+1F50D, UTF-8: F0 9F 94 8D

ifdef::backend-pdf[]
//include:: nomedoarquivo[]
// teste
endif::[]

[NOTE]
Esse material √© usado como apoio √†s aulas da disciplina de Testes de _software_
do Curso Superior de Tecnologia em Sistemas para WEB do Instituto Federal de Educa√ß√£o,
Ci√™ncia e Tecnologia do Tocantins - IFTO. Ele n√£o substitui livros t√©cnicos ou
outras fontes. Ele √© apenas um resumo para auxiliar o estudante.


[TIP]
Procure por outras fontes para complementar esse material. Um bom lugar para come√ßar
√© o site Infoq.com.br que traz palestras e artigos atualizados relacionados a
diversos aspectos da engenharia de _software_.

== Relembrando as atividades do processo de _software_
Antes de falarmos sobre os testes √© necess√°rio localiz√°-lo dentre os processos
da Engenharia de _software_. Existem uma grande quantidade de processos de
desenvolvimento de _software_ diferentes mas todos possuem as seguintes atividades:

- especifica√ß√£o ‚Äì defini√ß√£o do qu√™ o sistema deve fazer;
- projeto e implementa√ß√£o ‚Äì defini√ß√£o da organiza√ß√£o do sistema e implementa√ß√£o do
sistema;
- verifica√ß√£o e valida√ß√£o ‚Äì checagem de que o sistema faz o que o cliente deseja;
- evolu√ß√£o ‚Äì evolu√ß√£o em resposta a mudan√ßas nas necessidades do cliente.

Na primeira atividade, especifica√ß√£o, √© onde conseguimos obter um entendimento geral
sobre o problema a ser resolvido. N√£o temos todos os detalhes ainda, mas √© poss√≠vel
obter o m√≠nimo necess√°rio para passar para as pr√≥ximas etapas. Podemos dizer ainda
que essa etapa estabelece quais servi√ßos s√£o necess√°rios e quais s√£o as restri√ß√µes
na opera√ß√£o e desenvolvimento do sistema. A disciplina An√°lise de Sistemas √© a
respons√°vel por tratar dos assuntos relacionados a essa etapa.

Projeto e implementa√ß√£o √© uma atividade que pode ser entendida contendo duas partes
que dificilmente s√£o tratadas em separado dentro do mundo da computa√ß√£o e que t√™m
como objetivo a convers√£o da especifica√ß√£o do sistema em um sistema execut√°vel.
Em projeto criamos um _Design_ de uma estrutura de _software_ que possa materializar
a especifica√ß√£o; e por implementa√ß√£o devemos entender que √© o ato de transformar o
_Design_ em um programa execut√°vel. No curso de sistemas para internet a disciplina
Projeto de _software_ √© respons√°vel por apresentar as t√©cnicas e ferramentas utilizadas
para a elabora√ß√£o de estrutura do _software_. J√° implementa√ß√£o est√° fracionada em
v√°rias disciplinas tais como Programa√ß√£o Orientada ao Objeto, Programa√ß√£o para WEB,
dentre outras.

A terceira atividade, Verifica√ß√£o e valida√ß√£o (V&V) tem o objetivo de mostrar que o
produto que estamos construindo, um sistema por exemplo,  est√° em conformidade
com sua especifica√ß√£o e ainda que ele est√° de acordo com os requisitos do
cliente. Essa etapa √© o objeto de estudo desta disciplina.

Por fim, temos a atividade chamada de evolu√ß√£o de _software_ ocorre quando √©
necess√°rio alterar um sistema que j√° existe, tornando-o adequado a novas necessidades.
Devemos lembrar que
qualquer _software_ precisa evoluir, pois caso isso n√£o aconte√ßa, ele deixar√° de atender
√†s necessidades de seus usu√°rios o que pode torna-lo √∫til em pouco tempo. N√£o h√°
disciplina que espec√≠fica no Curso de Sistema para Internet do IFTO e provavelmente
em nenhum outro curso que lide diretamente com essa quest√£o.

=== Quando a atividade de testes inicia?
A resposta para essa pergunta depende da maneira como as atividades do processo de
_software_ est√£o organizadas. Resumidamente, tudo depende do paradigma que est√° sendo
usado. Assim, se estamos trabalhando em um paradigma orientado a planos, como o
modelo cascata, elas s√£o organizadas em sequ√™ncia. Isso significa que os testes
s√≥ come√ßar√£o ap√≥s as atividade de implementa√ß√£o terem sido conclu√≠das. J√° se estivermos
falando sobre um ambiente que usa um modelo incremental, tal qual os modelos √Ågeis,
as atividades de projeto e implementa√ß√£o e de verifica√ß√£o e valida√ß√£o s√£o intercaladas.
Para clarificar um pouco mais, a seguir os modelos em cascata e incremental s√£o
apresentados e as figuras <<#modeloCascata>> e <<desenvolvimentoIncremental>>
mostram como as atividades s√£o organizadas.

==== Testes no modelo cascata
[#modeloCascata]
.Exemplo do modelo em cascata
//[link=https://cdn-images-1.medium.com/max/1200/1*5vlem2hirY1jr_jXt8-QZA.png]
image::Modelo-cascata.png[modeloCascata,600,400]

Antes de mais nada √© importante lembrar que o esse modelo, que pode ser chamado de
ciclo de vida cl√°ssico, que segue uma abordagem sistem√°tica e sequencial pode ser
usado em cen√°rios em os requisitos s√£o bem entendidos ou que mudam pouco. Esse √©
o paradigma mais antigo da Engenharia de _software_, tendo provavelmente sido introduzido
por engenheiros de outras √°reas.

No modelo cascata as atividades precisam ser completadas antes de se mover
para a pr√≥xima. √â poss√≠vel a realiza√ß√£o de testes durante a etapa de implementa√ß√£o,
onde √© poss√≠vel que sejam executados de v√°rios testes de desenvolvimento. Depois que
esses testes tenham sido conclu√≠dos com √™xito √© que podemos passar para a verifica√ß√£o
e realizar outros tipos de testes, como os testes de sistema e testes de usu√°rio. Mas
para atingirmos essas etapas devemos ter conclu√≠da as outras duas.

==== Testes no modelo incremental

Segundo Pressman, h√° muitas situa√ß√µes em que os requisitos iniciais s√£o razoavelmente
definidos e pode haver a necessidade de fornecer rapidamente um conjunto limitado
de funcionalidades do _software_ aos usu√°rios que ser√° aumentado em vers√µes posteriores.
Em situa√ß√µes como essa, um modelo incremental pode ser escolhido.

[#desenvolvimentoIncremental]
.Exemplo do modelo incremental
//[link=https://cdn-images-1.medium.com/max/1200/1*5vlem2hirY1jr_jXt8-QZA.png]
image::desenvolvimentoincremental2.png[desenvolvimentoIncremental,600,400]

O modelo incremental √© mais flex√≠vel que o modelo cascata. Tudo come√ßa com um esbo√ßo
do sistema. Uma vez que esse esbo√ßo seja feito √© poss√≠vel passar para a pr√≥xima
atividade que intercala especifica√ß√£o, desenvolvimento e valida√ß√£o. Isso significa
que a parir do esbo√ßo √© poss√≠vel especificar os requisitos, aplicar t√©cnicas de
projeto e fazer a implementa√ß√£o e realizar a valida√ß√£o. Essas valida√ß√µes permitem
que sejam entregues vers√µes intermedi√°rias que s√£o na verdade um produto operacional.

== O que √© teste de _software_
O teste de _software_ √© uma atividade que tem o objetivo de verificar se os resultados
obtidos atrav√©s do uso do produto correspondem aos resultados esperados. Al√©m disso,
ela √© respons√°vel tamb√©m por tentar fazer como que sistema que est√° sendo testado
esteja livre de Defeitos.

Roger Pressmann, diz que o *teste de _software_ faz parte de um processo amplo ao
qual podemos chamar de  Verifica√ß√£o e Valida√ß√£o (V&V)*, sendo que por verifica√ß√£o
estamos nos referindo a um conjunto de atividade que est√£o relacionadas com a
garantia de que o _software_ "implementa corretamente uma fun√ß√£o espec√≠fica". J√°
a Valida√ß√£o tem como preocupa√ß√£o o atendimento os requisitos do cliente.

Segundo Ian Sommerville, o teste de _software_ √© uma etapa dentro do ciclo de vida
que *tem como objetivo descobrir os defeitos que um programa possui antes que ele
entre em produ√ß√£o*, isto √© antes de ser entregue para que os usu√°rios comecem a
utiliz√°-lo.

Edsger Dijkstra, argumenta que *os testes apenas s√£o capazes de mostrar a presen√ßa
de erros e n√£o a sua aus√™ncia*, pois √© poss√≠vel de usar uma entrada de dados de
testes que n√£o seja boa ou at√© mesmo esquecermos de testar alguma parte do sistema.
Assim, os testes n√£o conseguem demonstrar que n√£o h√° defeitos ou que ele sempre se
comportar√° da maneira prevista em qualquer situa√ß√£o.

Podemos entender o teste √© um processo independente, pois nem sempre quem desenvolve
testar√° o _software_. Al√©m disso, cumpre lembrar que n√∫mero de tipos diferentes de
teste varia tanto quanto as t√©cnicas de desenvolvimento.

‚Ä¢ Envolve processos de inspe√ß√£o e revis√£o, e testes do sistema.
‚Ä¢ Testes do sistema envolvem executar o sistema com casos de teste. S√£o
provenientes de especifica√ß√µes dos dados reais que dever√£o ser processados
pelo sistema.
‚Ä¢ O teste √© a atividade de V & V mais usada.


=== Por que executar testes de _software_?

O teste √© importante porque os erros de _software_ podem ser caros ou at√© tornarem-se
perigosos. Erros de _software_ podem causar perdas monet√°rias e humanas, a hist√≥ria
est√° cheia de exemplos.

- O Voo 501 da Ag√™ncia Espacial Europ√©ia Ariane 5 foi destru√≠do 40 segundos ap√≥s
 a decolagem (4 de junho de 1996). O prot√≥tipo de foguete de US $ 1 bilh√£o foi
 destru√≠do devido a um bug no _software_ de orienta√ß√£o a bordo.

video::gp_D8r-2hwk[youtube]


https://www.guru99.com/software-testing-introduction-importance.html
https://www.scientificamerican.com/article/pogue-5-most-embarrassing-software-bugs-in-history/
http://tryqa.com/what-is-software-testing/

Em um alto n√≠vel, o teste de _software_ √© necess√°rio para detectar os bugs no _software_
 e para testar se o _software_ atende aos requisitos do cliente. Isso ajuda a equipe
  de desenvolvimento a corrigir os erros e entregar um produto de boa qualidade.

H√° v√°rios pontos no processo de desenvolvimento de _software_ em que o erro humano
pode levar a um _software_ que n√£o atende aos requisitos dos clientes. Alguns deles
est√£o listados abaixo.

- O cliente / pessoa que fornecer os requisitos em nome da organiza√ß√£o do cliente
pode n√£o saber exatamente o que √© necess√°rio ou pode esquecer de fornecer alguns
detalhes, o que pode levar √† falta de recursos.

- A pessoa que est√° coletando os requisitos pode interpretar erroneamente ou perder
completamente um requisito quando document√°-los.

- Durante a fase de design, se houver problemas no design, isso pode levar a erros
no futuro

- _Bugs_ podem ser introduzidos durante a fase de desenvolvimento durante o erro humano,
falta de experi√™ncia, etc.

- Os testadores podem perder erros durante a fase de testes devido a erro humano,
falta de tempo, experi√™ncia insuficiente, etc.

- Os clientes podem n√£o ter a largura de banda para testar todos os recursos do produto
e podem liberar o produto para seus usu√°rios finais, o que pode levar os usu√°rios
finais a encontrar erros no aplicativo


Um neg√≥cio e reputa√ß√£o de organiza√ß√µes depende da qualidade de seus produtos e,
em alguns casos, at√© a receita pode depender das vendas de produtos de _software_.

Os usu√°rios podem preferir comprar um produto concorrente em um produto que tenha
qualidade ruim e isso pode resultar em perda de receita para a organiza√ß√£o.
No mundo de hoje, a qualidade √© uma das principais prioridades de qualquer
organiza√ß√£o.


=== Como o material est√° organizado



== Quais os n√≠veis de teste?
H√° sete n√≠veis::

Testes de unidade::: Realizados pelos programadores - pode ser automatizado. O teste de unidade
focaliza o esfor√ßo de verifica√ß√£o na menor unidade do projeto de _software_ -- o
componente ou m√≥dulo de _software_. A partir de uma documenta√ß√£o √© poss√≠vel verificar
quais os caminhos de controle a serem testados a fim de que seja poss√≠vel encontrar
erros dentro desse m√≥dulo. Os testes de unidade, muitas vezes chamados de testes unit√°rios,
testar√£o m√©todos ou classes, uma vez que eles normalmente s√£o as menores unidades
do projeto.

[#tdd]
.O ciclo do TDD
//[link=https://cdn-images-1.medium.com/max/1200/1*5vlem2hirY1jr_jXt8-QZA.png]
image::tdd.png[testeAB,600,400]

*Beneficios do TDD*

Cobertura de c√≥digo::: Cada segmento de c√≥digo que voc√™ escreve deve ter pelo menos um teste associado,
para todo o c√≥digo escrito tem pelo menos um teste.

Testes de regress√£o::: Um conjunto de testes de regress√£o √© desenvolvido de forma incremental enquanto
um programa √© desenvolvido.

Depura√ß√£o simplificada::: Quando um teste falhar, deve ser √≥bvio onde est√° o problema. O c√≥digo rec√©m-escrito
tem de ser verificado e modificado.

Documenta√ß√£o de sistema::: Os pr√≥prios testes s√£o uma forma de documenta√ß√£o que descreve o que o c√≥digo
deve estar fazendo.
‚Ä®
Testes de integra√ß√£o::: Realizados pelos programadores - pode ser automatizado.
Tamb√©m conhecido como teste de componente, uma vez que os componentes de um sistema
s√£o formados por diversos objetos de classes diferentes que interagem. √â uma t√©cnica
sistem√°tica que permite a constru√ß√£o da arquitetura do _software_ e simultaneamente,
conduz os testes para descobrir erros associados √†s interfaces. Devemos entender
que interfaces s√£o o mecanismo usado para que as unidades, ou m√≥dulos, troquem
informa√ß√µes. Assim, o teste de integra√ß√£o far√° como que duas ou mais classes, por
exemplo, sejam postas em funcionamento juntas. Se individualmente elas funcionaram,
quando colocadas juntas, elas devem continuar funcionando.

Teste de sistema::: testadores - testes manuais. Envolve a integra√ß√£o de v√°rios
componentes para a cria√ß√£o de uma vers√£o do sistema. Esse teste verifica se os
componentes s√£o compat√≠veis, se interagem de maneira esperada e se executam as
comunica√ß√µes com outros ...

Teste de aceita√ß√£o::: usu√°rios - testes manuais
Teste Alfa::: Realizados pelos usu√°rios - testes manuais. S√£o testes realizados em um ambiente controlado
pelo dessenvolvedor que registra os problemas de uso e os erros que aconteceram.
Teste Beta::: Realizados pelos usu√°rios mais usu√°rios - testes manuais. Os testes s√£o feitos no ambiente do
usu√°rio. Mais mais dificil para o desenvolvedor acompanhar uma vez que podem haver uma
quantidade muito grande de usu√°rios.

Teste de regress√£o (reteste)::: Cada vez que um novo m√≥dulo √© adicionado como parte
do teste de integra√ß√£o, o _software_ se modifica. Novos caminhos de fluxo de dados
s√£o estabelecidos, nova E/S pode ocorrer e nova l√≥gica de controle √© acionada.
Assim sendo, tudo o que havia sido previamente testado corre o risco de apresentarem
problemas. Esse tipo de teste ajuda a garantir que modifica√ß√µes n√£o introduzam
algum comportamento indesej√°vel ou erros adicionais.

== Quais s√£o as t√©cnicas de Teste

* Caixa Branca ( caixa aberta  - visualiza o c√≥digo fonte - Teste de unidade, testes est√°ticos ( an√°lise do c√≥digo, sem executar-lo ) )
** Teste de m√©todos e Classes, Testes de comando de repeti√ß√£o, teste de condi√ß√µes
*** Teste de cobertura
*** Teste de Caminhos
*** Teste de comandos
*** Teste de condi√ß√µes

* Caixa Preta ( n√£o vejo o interior - √© baseado em entradas e sa√≠das - Teste de integra√ß√£o, Teste de sistema, Teste de Aceita√ß√£o, Teste Alfa, Teste Beta )
Teste baseado em entradas e sa√≠das de Cen√°rios Macro
	- Teste baseado em cen√°rios
	- Teste baseado em Casos de uso
	- An√°lise de Valores limites

== Quais s√£o os tipos de teste
- Teste de funcionalidade
- Teste de interface
- Teste de desempenho
- Teste de usabilidade
- Teste de seguran√ßa
- Teste usu√°rio


=== Testes de usabilidade
Os testes devem ser realizados independentemente do tamanho do projeto e da estrutura
dispon√≠vel, pois sempre revelam aspectos que influenciar√£o com mais ou menos profundidade
o produto final. Os principais objetivos dos testes s√£o:

- Permitir que cada usu√°rio realize a tarefa a que se prop√µe ao usar a interface,
 em um tempo razo√°vel. Se a utiliza√ß√£o √© f√°cil, precisa, auto-explicativa,
 relativamente r√°pida, mas n√£o atende a uma necessidades clara, n√£o tem muita
 utilidade. Ou valor.

- Tornar o uso da interface o mais intuitivo poss√≠vel. Quanto menos tempo o
usu√°rio leva para realizar seu objetivo no website, maior e seu grau de satisfa√ß√£o
 com a interface.

- Verificar a atitude positiva ou negativa do usu√°rio durante a experi√™ncia de uso.
Neste caso, ‚Äúatitude‚Äù se refere a percep√ß√µes, sentimentos, opini√µes do usu√°rio,
que podem ser verificadas por meio de entrevistas orais ou escritas.

As pessoas tendem a realizar melhor as suas tarefas e objetivos ao usar uma interface quando esta os agrada de maneira geral e lhes √© familiar. Estabelecer consenso na equipe de projeto ou manuten√ß√£o evolutiva sobre os resultados esperados. Os testes podem diminuir as d√∫vidas e discord√¢ncias sobre as solu√ß√µes e decis√µes adotadas. Os objetivos de testes como os citados acima podem ser baseados em aspectos quantitativos, mas n√£o se resumir a estat√≠sticas sobre o uso e a satisfa√ß√£o do uso. √â importante tamb√©m considerar aspectos qualitativos, mais subjetivos, que comp√µem quadros mais completos do contexto de uso.

Os testes de usabilidade fazem com que o desenvolvedor/testador fique junto ao usu√°rio.
O objetivo √© aprender como ele realmente usa seu produto. O desenvolvedor escolhe
algumas tarefas que ele precisa realizar e assiste e registra ele os locais em
surgiram algum tipo de dificuldades. Este teste ajuda a criar hip√≥teses de melhoria
do produto.




=== Testes de usu√°rio

S√£o testes onde os usu√°rios ou clientes usam o _software_ a fim de fornecer um _feedback_.
Assim, eles experimentam o _software_ para ver se gostam desse produto e verificam tamb√©m se
ele est√° em conformidade com a suas necessidades.

De modo geral, os testes de usu√°rio ajudam a verificar se a interface permite o uso f√°cil
e intuitivo, se prov√™ funcionalidades que os usu√°rios valorizam e se
proporciona, de modo geral, uma experi√™ncia de uso satisfat√≥ria.

O teste de usu√°rio √© essencial, mesmo em sistemas abrangentes ou quando testes de
 release tenham sido feitos. O motivo √© que a influencia realizada pelo ambiente
 de trabalho do usu√°rio interfere muito sobre a confiabilidade, o desempenho, a
 usabilidade e a robustez de um sistema, tendo em vista que para o desenvolvedor √©
 praticamente imposs√≠vel replicar o ambiente de trabalho em que todos os poss√≠veis
 usu√°rios estar√£o.

Sobre o teste de aceita√ß√£o √© importante lembrar que os clientes querem usar o
_software_ assim que poss√≠vel por causa dos benef√≠cios que podem ser obtidos. Os
testes de aceita√ß√£o podem n√£o terem obtido um bom resultado mas devido a uma s√©ria
de outros fatores, a ado√ß√£o do produto pode come√ßar mesmo assim.



Podemos separar os testes de usu√°rio em tr√™s categorias:

 - Teste Alfa
 - Teste Beta
 - Teste de aceita√ß√£o

Os testes de aceita√ß√£o possuem seis est√°gios a saber:

 . Definir crit√©rios de aceita√ß√£o
 . Planejar os testes de aceita√ß√£o
 . Derivar testes
 . Executar testes
 . Negociar resultados dos testes
 . Rejeitar / aceitar o sistema

[#testeAB]
.A mountain sunset
//[link=https://cdn-images-1.medium.com/max/1200/1*5vlem2hirY1jr_jXt8-QZA.png]
image::testesAB.png[testeAB,300,200]


As pesquisas atitudinais s√£o focadas no que as pessoas falam que acreditam
(por exemplo, ao responderem um formul√°rio online ou em uma conversa dentro de
um grupo focal (_focus group_)), enquanto as pesquisas comportamentais analisam
o que as pessoas fazem (por exemplo, em um teste de usabilidade, ou em testes A/B).


https://brasil.uxdesign.cc/muito-al√©m-do-teste-de-usabilidade-os-v√°rios-tipos-de-pesquisas-com-usu√°rios-em-ux-b91a6e15bc61



Testes A/B
